on script load:
    load yaml "plugins/Skript/dungeonconfig/siegeofspawn/SpawnLocations.yml" as "SOSspawnlocations"
#import:
    #org.bukkit.World

function SOSSpawnInstance(keystoneId: text, partySize: integer, instance: integer, affixes: texts = ""):
    #BALTHAZAR
    set {_BalthazarLoc} to yaml value "Balthazar" from "SOSspawnlocations"
    #The Council of Admins
    set {_councilmerimelleLoc} to yaml value "The Council of Admins (merimelle)" from "SOSspawnlocations"
    set {_councilPehrekLoc} to yaml value "The Council of Admins (Pehrek)" from "SOSspawnlocations"
    #GOSHA
    set {_GoshaLoc} to yaml value "Gosha" from "SOSspawnlocations"
    #DREAMCATCHER
    set {_DreamcatcherLoc} to yaml value "Dreamcatcher" from "SOSspawnlocations"
    set {_councilmerimelle} to (SOSTheCouncilOfAdminsSpawnmerimelle({_councilmerimelleLoc}, {_keystoneId}, {_partySize}, {_instance}, {_affixes::*})) parsed as entity
    set {_councilPehrek} to (SOSTheCouncilOfAdminsSpawnPehrek({_councilPehrekLoc}, {_keystoneId}, {_partySize}, {_instance}, {_affixes::*})) parsed as entity
    set {_Balthazar} to (SOSSpawnBalthazar({_BalthazarLoc}, {_keystoneId}, {_partySize}, {_instance}, {_affixes::*})) parsed as entity
    set {_Gosha} to (SOSSpawnGosha({_GoshaLoc}, {_keystoneId}, {_partySize}, {_instance}, {_affixes::*})) parsed as entity
    set {_Dreamcatcher} to (SOSSpawnDreamcatcher({_DreamcatcherLoc}, {_keystoneId}, {_partySize}, {_instance}, {_affixes::*})) parsed as entity
    #COUNCIL ARMOR STANDS
    set {_custom} to tag "custom" of nbt of {_councilmerimelle}
    set tag "ECBossPartner" of {_custom} to (uuid of {_councilPehrek})
    set {_custom} to tag "custom" of nbt of {_councilPehrek}
    set tag "ECBossPartner" of {_custom} to (uuid of {_councilmerimelle})
    set {_ArmorStand1} to yaml value "ArmorStand1" from "SOSspawnlocations"
    set {_ArmorStand2} to yaml value "ArmorStand2" from "SOSspawnlocations"
    if {-affixes%{_instance}%::*} contains "Inspiring":
        broadcast "Contains inspiring"
        set {_inspiring} to true

    #MOBS
    loop 2 times:
        set {_ar} to SOSMobSpawn({_ArmorStand%loop-number%}, zombie, "&fKnight Armor", iron sword, "Ghost", 0, {_keystoneId}, {_partySize}, 15, {_instance}, {_affixes::*})
        set {_pot} to potion effect of speed of tier 1.3 without particles for 1 day
        add {_pot} to potion effects of {_ar}
        set metadata value "ArmorStand%loop-number%" of {_councilPehrek} to ({_ar} parsed as entity)
    
    #DESTRUCTION MAGE
    loop 15 times: 
        set {_destructionMage%loop-number%Loc} to yaml value "Destruction Mage%loop-number%" from "SOSspawnlocations"
        set {_mob} to SOSMobSpawn({_destructionMage%loop-number%Loc}, blaze, "Destruction Mage", air, "Fire", 1.8, {_keystoneId}, {_partySize}, 30, {_instance}, {_affixes::*}) parsed as entity
        if loop-number = 6:
            Inspiring({_mob}, {_inspiring}, {_instance})
        
    #DESTRUCTION ARCHER
    loop 6 times:
        set {_destructionArcher%loop-number%Loc} to yaml value "Destruction Archer%loop-number%" from "SOSspawnlocations"
        set {_mob} to SOSMobSpawn({_destructionArcher%loop-number%Loc}, skeleton, "Destruction Archer", bow, "Fire", 1.3, {_keystoneId}, {_partySize}, 24, {_instance}, {_affixes::*}) parsed as entity
        if loop-number = 2:
            Inspiring({_mob}, {_inspiring}, {_instance})
        
    #MAGIC TOME
    loop 11 times:
        set {_magicTome%loop-number%Loc} to yaml value "MagicTome%loop-number%" from "SOSspawnlocations"
        set {_mob} to SOSMobSpawn({_magicTome%loop-number%Loc}, bee, "Magic Tome", air, "Magic", 0.9, {_keystoneId}, {_partySize}, 17, {_instance}, {_affixes::*}) parsed as entity
        if loop-number = 2 or 6 or 8:
            Inspiring({_mob}, {_inspiring}, {_instance})
    
#-----BALTHAZAR
function SOSSpawnBalthazar(loc: location, keystoneId: string, partySize: integer, instance: integer, affixes: texts = "") :: string:
    spawn 1 blaze at {_loc} with nbt compound from "{Silent:1b}"
    set {_x} to last spawned blaze
    set the name of {_x} to "Balthazar"
    DungeonMobAssignment({_x}, true, 70, 0)
    set {_custom} to tag "custom" of nbt compound of {_x}
    set {_potion} to potion effect of speed of tier 3.5 without particles for 24 hours
    add {_potion} to potion effects of {_x}
    set metadata value "ECBossBarColor" of {_x} to magenta
    set metadata value "ECMobSpawnLoc" of {_x} to {_loc}
    set {_loc} to location of last spawned blaze
    increase {_loc}'s y-coordinate by 1.55
    spawn 1 armor stand at {_loc} with nbt from "{Marker:1b,Invulnerable:1b,Invisible:1b}"
    set tag "ECEnergy" of {_custom} to 0
    set {_energy} to tag "ECEnergy" of {_custom}
    set display name of last spawned armor stand to "&6&lBOSS"
    set tag "ECTextAbove" of {_custom} to uuid of last spawned armor stand
    set tag "ECDungeonInstance" of {_custom} to {_instance}
    set tag "ECElement" of {_custom} to "Magic"
    set tag "ECInstanceName" of {_custom} to "Siege of Spawn"
    set tag "ECPartySize" of {_custom} to {_partySize}
    set tag "Affixes" of {_custom} to {_affixes::*}
    add nbt from "{Attributes:[{Name:""generic.follow_range"",Base:60}]}" to nbt of {_x}
    set {_ug} to uuid of last spawned armor stand
    set {_uuid} to uuid of {_x}
    disguise {_x} as "Balthazar"
    set custom name of {_x}'s disguise to "Balthazar"
    set skin of {_x}'s disguise to "BalthazarNormal"
    set {_keystonelevel} to {-KeystoneLevel%{_instance}%}
    set {_healthModifier} to KeystoneModifiers({_keystonelevel})
    set {_damageModifier} to KeystoneModifiers({_keystonelevel})
    if {_affixes::*} contains "Tyrannical":
        set {_tyrannicalModifier} to 1.3
        set tag "custom;TyrannicalModifier" of nbt of {_x} to 1.15
    set max health of {_x} to 80*({_healthModifier})*{_partySize}
    if {_tyrannicalModifier} is set:
        set max health of {_x} to (max health of {_x}*{_tyrannicalModifier})
    heal {_x}
    set tag "DamageModifier" of {_custom} to ({_damageModifier})
    set metadata value "KeystoneId" of {_x} to {_keystoneId}
    load chunk at location of {_x} with ticket
    return uuid of {_x}
#-----The Council of Admins
#LILA
function SOSTheCouncilOfAdminsSpawnmerimelle(loc: location, keystoneId: string, partySize: integer, instance: integer, affixes: texts = "") :: string:
    spawn 1 skeleton at {_loc} with nbt compound from "{Silent:1b}"
    set {_x} to last spawned skeleton
    set the name of {_x} to "&fmerimelle"
    set {_x}'s tool to (bow with nbt from "{CustomModelData:1}")
    DungeonMobAssignment({_x}, true, 70, 0)
    set {_custom} to tag "custom" of nbt compound of {_x}
    set {_potion} to potion effect of speed of tier 3.5 without particles for 24 hours
    add {_potion} to potion effects of {_x}
    set metadata value "ECBossBarColor" of {_x} to blue
    set metadata value "ECMobSpawnLoc" of {_x} to {_loc}
    set {_loc} to location of last spawned skeleton
    increase {_loc}'s y-coordinate by 1.55
    spawn 1 armor stand at {_loc} with nbt from "{Marker:1b,Invulnerable:1b,Invisible:1b}"
    set tag "ECEnergy" of {_custom} to 0
    set {_energy} to tag "ECEnergy" of {_custom}
    set display name of last spawned armor stand to "&6&lBOSS &e(%{_energy}%)"
    set tag "ECTextAbove" of {_custom} to uuid of last spawned armor stand
    set tag "ECDungeonInstance" of {_custom} to {_instance}
    set tag "ECElement" of {_custom} to "Water"
    set tag "ECInstanceName" of {_custom} to "Siege of Spawn"
    set tag "ECPartySize" of {_custom} to {_partySize}
    set tag "Affixes" of {_custom} to {_affixes::*}
    add nbt from "{Attributes:[{Name:""generic.follow_range"",Base:60}]}" to nbt of {_x}
    set {_ug} to uuid of last spawned armor stand
    set {_uuid} to uuid of {_x}
    execute console command "/disguuid %{_uuid}% player merimelle setCustomName ""merimelle"" setDynamicName true setCustomNameVisible true setSkin SOSCouncilmeri"
    set {_keystonelevel} to {-KeystoneLevel%{_instance}%}
    set {_healthModifier} to KeystoneModifiers({_keystonelevel})
    set {_damageModifier} to KeystoneModifiers({_keystonelevel})
    if {_affixes::*} contains "Tyrannical":
        set {_tyrannicalModifier} to 1.3
        set tag "custom;TyrannicalModifier" of nbt of {_x} to 1.15
    set max health of {_x} to 100*({_healthModifier})*{_partySize}
    if {_tyrannicalModifier} is set:
        set max health of {_x} to (max health of {_x}*{_tyrannicalModifier})
    heal {_x}
    set tag "DamageModifier" of {_custom} to ({_damageModifier})
    set metadata value "KeystoneId" of {_x} to {_keystoneId}
    load chunk at location of {_x} with ticket
    return uuid of {_x}
#PEHREK
function SOSTheCouncilOfAdminsSpawnPehrek(loc: location, keystoneId: string, partySize: integer, instance: integer, affixes: texts = "") :: string:
    spawn 1 zombie at location 3 west of {_loc} with nbt compound from "{Silent:1b}"
    set {_x} to last spawned zombie
    set the name of {_x} to "&fPehrek"
    set {_x}'s tool to (iron sword with nbt from "{CustomModelData:2}")
    set {_x}'s offhand item to (iron sword with nbt from "{CustomModelData:1}")
    DungeonMobAssignment({_x}, true, 70, 0)
    set {_custom} to tag "custom" of nbt compound of {_x}
    set metadata value "ECBossBarColor" of {_x} to purple
    set {_potion} to potion effect of speed of tier 4 without particles for 24 hours
    add {_potion} to potion effects of {_x}
    set metadata value "ECMobSpawnLoc" of {_x} to {_loc}
    set {_loc} to location of last spawned zombie
    increase {_loc}'s y-coordinate by 1.55
    spawn 1 armor stand at {_loc} with nbt from "{Marker:1b,Invulnerable:1b,Invisible:1b}"
    set tag "ECEnergy" of {_custom} to 0
    set {_energy} to tag "ECEnergy" of {_custom}
    set display name of last spawned armor stand to "&6&lBOSS &e(%{_energy}%)"
    set tag "ECTextAbove" of {_custom} to uuid of last spawned armor stand
    set tag "ECDungeonInstance" of {_custom} to {_instance}
    set tag "ECBossPartner" of {_custom} to name of {_z}
    set tag "ECElement" of {_custom} to "Ghost"
    set tag "ECInstanceName" of {_custom} to "Siege of Spawn"
    set tag "ECPartySize" of {_custom} to {_partySize}
    set tag "Affixes" of {_custom} to {_affixes::*}
    add nbt from "{Attributes:[{Name:""generic.follow_range"",Base:60}]}" to nbt of {_x}
    set {_ug} to uuid of last spawned armor stand
    set {_uuid} to uuid of {_x}
    execute console command "/disguuid %{_uuid}% player Pehrek setCustomName ""&fPehrek"" setDynamicName true setCustomNameVisible true setSkin SOSCouncilPehrek"
    set {_keystonelevel} to {-KeystoneLevel%{_instance}%}
    set {_healthModifier} to KeystoneModifiers({_keystonelevel})
    set {_damageModifier} to KeystoneModifiers({_keystonelevel})
    if {_affixes::*} contains "Tyrannical":
        set {_tyrannicalModifier} to 1.3
        set tag "custom;TyrannicalModifier" of nbt of {_x} to 1.15
    set max health of {_x} to 100*({_healthModifier})*{_partySize}
    if {_tyrannicalModifier} is set:
        set max health of {_x} to (max health of {_x}*{_tyrannicalModifier})
    heal {_x}
    set tag "DamageModifier" of {_custom} to ({_damageModifier})
    set metadata value "KeystoneId" of {_x} to {_keystoneId}
    load chunk at location of {_x} with ticket
    return uuid of {_x}
#-----GOSHA
function SOSSpawnGosha(loc: location, keystoneId: string, partySize: integer, instance: integer, affixes: texts = "") :: string:
    spawn 1 zombie at {_loc} with nbt compound from "{Silent:1b}"
    set {_x} to last spawned zombie
    set the name of {_x} to "Gosha"
    DungeonMobAssignment({_x}, true, 70, 0)
    set tag "ECMob" of nbt of {_x} to true
    set {_custom} to tag "custom" of nbt compound of {_x}
    set {_potion} to potion effect of speed of tier 1.9 without particles for 24 hours
    add {_potion} to potion effects of {_x}
    set metadata value "ECBossBarColor" of {_x} to red
    set metadata value "ECMobSpawnLoc" of {_x} to {_loc}
    set {_loc} to location of last spawned zombie
    increase {_loc}'s y-coordinate by 1.55
    spawn 1 armor stand at {_loc} with nbt from "{Marker:1b,Invulnerable:1b,Invisible:1b}"
    set tag "ECEnergy" of {_custom} to 0
    set {_energy} to tag "ECEnergy" of {_custom}
    set display name of last spawned armor stand to "&6&lBOSS"
    set tag "ECTextAbove" of {_custom} to uuid of last spawned armor stand
    set tag "ECDungeonInstance" of {_custom} to {_instance}
    set tag "ECElement" of {_custom} to "Poison"
    set tag "ECInstanceName" of {_custom} to "Siege of Spawn"
    set tag "ECModelHeight" of {_custom} to 1.1
    set tag "MeleeDamage" of {_custom} to 2
    set tag "ECPartySize" of {_custom} to {_partySize}
    set tag "Affixes" of {_custom} to {_affixes::*}
    add nbt from "{Attributes:[{Name:""generic.follow_range"",Base:60}]}" to nbt of {_x}
    set {_ug} to uuid of last spawned armor stand
    set {_uuid} to uuid of {_x}
    set custom name of {_x}'s disguise to "Gosha"
    set {_keystonelevel} to {-KeystoneLevel%{_instance}%}
    set {_healthModifier} to KeystoneModifiers({_keystonelevel})
    set {_damageModifier} to KeystoneModifiers({_keystonelevel})
    if {_affixes::*} contains "Tyrannical":
        set {_tyrannicalModifier} to 1.3
        set tag "custom;TyrannicalModifier" of nbt of {_x} to 1.15
    set max health of {_x} to 140*({_healthModifier})*{_partySize}
    if {_tyrannicalModifier} is set:
        set max health of {_x} to (max health of {_x}*{_tyrannicalModifier})
    heal {_x}
    set tag "DamageModifier" of {_custom} to ({_damageModifier})
    set metadata value "KeystoneId" of {_x} to {_keystoneId}
    execute console command "/disguuid %{_uuid}% mushroom_cow setCustomName ""Gosha"" setDynamicName true setCustomNameVisible true"
    load chunk at location of {_x} with ticket
    return uuid of {_x}
#-----DREAMCATCHER
function SOSSpawnDreamcatcher(loc: location, keystoneId: string, partySize: integer, instance: integer, affixes: texts = "") :: string:
    set yaw of {_loc} to 107
    set pitch of {_loc} to 32
    spawn 1 ghast at {_loc} with nbt compound from "{Silent:1b}"
    set {_x} to last spawned ghast
    set the name of {_x} to "Dreamcatcher"
    DungeonMobAssignment({_x}, true, 70, 0)
    set tag "ECMob" of nbt of {_x} to true
    set {_custom} to tag "custom" of nbt compound of {_x}
    set metadata value "ECBossBarColor" of {_x} to white
    set metadata value "ECMobSpawnLoc" of {_x} to {_loc}
    set {_loc} to location of last spawned ghast
    increase {_loc}'s y-coordinate by 1.55
    spawn 1 armor stand at {_loc} with nbt from "{Marker:1b,Invulnerable:1b,Invisible:1b}"
    set tag "ECEnergy" of {_custom} to 0
    set {_energy} to tag "ECEnergy" of {_custom}
    set display name of last spawned armor stand to "&6&lBOSS"
    set tag "ECTextAbove" of {_custom} to uuid of last spawned armor stand
    set tag "ECDungeonInstance" of {_custom} to {_instance}
    set tag "ECElement" of {_custom} to "Air"
    set tag "ECInstanceName" of {_custom} to "Siege of Spawn"
    set tag "ECModelHeight" of {_custom} to 1.65
    set tag "MeleeDamage" of {_custom} to 2
    set tag "ECPartySize" of {_custom} to {_partySize}
    set tag "Affixes" of {_custom} to {_affixes::*}
    add nbt from "{Attributes:[{Name:""generic.follow_range"",Base:60}]}" to nbt of {_x}
    set {_ug} to uuid of last spawned armor stand
    set {_uuid} to uuid of {_x}
    disguise {_x} as "Dreamcatcher"
    set skin of {_x}'s disguise to "Dreamcatcher"
    set custom name of {_x}'s disguise to "Dreamcatcher"
    set {_keystonelevel} to {-KeystoneLevel%{_instance}%}
    set {_healthModifier} to KeystoneModifiers({_keystonelevel})
    set {_damageModifier} to KeystoneModifiers({_keystonelevel})
    if {_affixes::*} contains "Tyrannical":
        set {_tyrannicalModifier} to 1.3
        set tag "custom;TyrannicalModifier" of nbt of {_x} to 1.15
    set max health of {_x} to 110*({_healthModifier})*{_partySize}
    if {_tyrannicalModifier} is set:
        set max health of {_x} to (max health of {_x}*{_tyrannicalModifier})
    heal {_x}
    set tag "DamageModifier" of {_custom} to ({_damageModifier})
    set metadata value "KeystoneId" of {_x} to {_keystoneId}
    load chunk at location of {_x} with ticket
    return uuid of {_x}
function SOSMobSpawn(loc: location, e: entity type, name: text, i: item, element: text, percent: number, keystoneId: string, partySize: integer, maxHealth: number, instance: integer, affixes: texts = "") :: string:
    spawn {_e} at {_loc} with nbt compound from "{Silent:1b}"
    set {_x} to last spawned entity
    set the name of {_x} to {_name}
    set {_x}'s tool to {_i}
    DungeonMobAssignment({_x}, false, 70, {_percent})
    set metadata value "ECMobSpawnLoc" of {_x} to {_loc}
    set {_custom} to tag "custom" of nbt compound of {_x}
    set {_loc} to location of last spawned entity
    increase {_loc}'s y-coordinate by 1.55
    if {_name} does not contain "Knight Armor":
        if {_e} is not a sheep:
            spawn 1 armor stand at {_loc} with nbt from "{Marker:1b,Invulnerable:1b,Invisible:1b}"
            set display name of last spawned armor stand to "&a|||||||||| &f(100%%)"
            set tag "ECTextAbove" of {_custom} to uuid of last spawned armor stand
    set tag "ECDungeonInstance" of {_custom} to {_instance}
    set tag "ECElement" of {_custom} to {_element}
    set tag "ECInstanceName" of {_custom} to "Siege of Spawn"
    set tag "ECPartySize" of {_custom} to {_partySize}
    set tag "Affixes" of {_custom} to {_affixes::*}
    add nbt from "{Attributes:[{Name:""generic.follow_range"",Base:60}]}" to nbt of {_x}
    set {_uuid} to uuid of {_x}
    if {_name} contains "Destruction Mage":
        disguise {_x} as "&fDestruction Mage"
        set skin of disguise of {_x} to "DestructionMage"
    #    execute console command "/disguuid %{_uuid}% player - setCustomName ""&fDestruction Mage"" setDynamicName true setCustomNameVisible true setSkin DestructionMage"
    else if {_name} contains "Destruction Archer":
        disguise {_x} as "&fDestruction Archer"
        set {_randomSkin} to a random integer between 1 and 2
        set skin of disguise of {_x} to "DestructionArcher%{_randomSkin}%"
        set {_x}'s tool to bow
    else if {_name} contains "Magic Tome":
        execute console command "/disguuid %{_uuid}% bee setCustomName ""Magic Tome"" setCustomNameVisible true"
        BlockFlowerPath({_x})
        set {_x}'s fly speed to 0.4
        set tag "ECModelHeight" of {_custom} to 0.25
    else if {_name} contains "Knight Armor":
        execute console command "/disguuid %{_uuid}% armor_stand setItemInOffHand IRON_SWORD setItemInMainHand IRON_SWORD setChestplate IRON_CHESTPLATE setLeggings IRON_LEGGINGS setBoots IRON_BOOTS sethelmet IRON_HELMET"
        add nbt from "{NoAI:1b}" to nbt of {_x}
        set tag "custom;ECSummon" of nbt of {_x} to true
    set {_keystonelevel} to {-KeystoneLevel%{_instance}%}
    set {_healthModifier} to KeystoneModifiers({_keystonelevel})
    set {_damageModifier} to KeystoneModifiers({_keystonelevel})
    if {_affixes::*} contains "Fortified":
        set {_fortifiedModifier} to 1.2
        set tag "custom;FortifiedModifier" of nbt of {_x} to 1.3
    set max health of {_x} to {_maxHealth}*({_healthModifier})*{_partySize}
    if {_fortifiedModifier} is set:
        set max health of {_x} to (max health of {_x}*{_fortifiedModifier})
    heal {_x}
    set tag "DamageModifier" of {_custom} to ({_damageModifier})
    set metadata value "KeystoneId" of {_x} to {_keystoneId}
    load chunk at location of {_x} with ticket
    return uuid of {_x}

on region enter:
    if "%region at event-entity%" contains "ASDtest":
        broadcast "!"

function UpdateTarget(e: entity, t: entity, aggroTarget: string):
    while {_e} is alive:
        if {_aggroTarget} = "dynamic":
            set {_v} to (first element of createTop("-threat::%uuid of {_e}%", 5, "[P]")) parsed as player
            if {_v} is not set:
                set {_v} to {_t}
            set {_e}'s target to {_v}
        else if {_aggroTarget} = "random":
            set {_instance} to tag "custom;ECDungeonInstance" of nbt of {_e}
            if size of {-dungeonInstance%{-instance}%::*} > 1:
                set {_random} to a random element of {-dungeonInstance%{-instance}%::*}
                set {_e}'s target to {_random}
            else:
                set {_e}'s target to {_t}
        else if {_aggroTarget} = "attacker":
            set {_e}'s target to {_t}
        wait 1 second

function MakeLook(e: entity, t: entity):
    while {_e} is alive:
        make {_e} look at {_t}
        wait 3 ticks

on death:
    if tag "custom" of nbt compound of victim is set:
        set {_custom} to tag "custom" of nbt compound of victim
        if tag "ECBoss" of {_custom} is set:
            if name of victim = "merimelle":
                #if {-intermissionLila::%victim%::*} is set:
                clear {-intermissionLila::%victim%::*}
                clear {-intermissionLilaloc::%victim%::*}

function Fireball(e: entity):
    set {_custom} to tag "custom" of nbt of {_e}
    set {_instance} to tag "ECDungeonInstance" of {_custom}
    while {_e} is alive:
        if metadata value "ECPulled" of {_e} is set:
            if {stun::%{_e}%} is not true:
                loop 3 times:
                    set {_target} to a random element of {-dungeonInstance%{_instance}%::*}
                    play sound "entity.blaze.shoot" with volume 3 and pitch 2 at {_e}
                    spawn 1 blaze fireball at {_e}
                    set metadata value "Shooter" of last spawned blaze fireball to uuid of {_e}
                    set metadata value "FirebalType" of last spawned blaze fireball to "Fireball"
                    set {_fireballs} to tag "ECFireballs" of {_custom}
                    if {_fireballs} is set:
                        add 1 to {_fireballs}
                    else:
                        set {_fireballs} to 1
                    push last spawned blaze fireball (vector from {_e} to {_target}) with speed 2
                    set tag "ECFireballs" of {_custom} to {_fireballs}
                    play 100 spawner flames with offset of 1.50, 1.50, 1.50 and speed 0 at {_e}
                    wait 0.5 seconds
                if {_fireballs} >= 9:
                    set {_target} to a random element of {-dungeonInstance%{_instance}%::*}
                    play sound "entity.blaze.shoot" with volume 3 and pitch 0.6 at {_e}
                    spawn 1 fireball at {_e}
                    set {_fireball} to last spawned entity
                    set metadata value "Shooter" of {_fireball} to uuid of {_e}
                    set tag "ECFireballs" of {_custom} to 0
                    push {_fireball} (vector from {_e} to {_target}) with speed 2
        wait 5 seconds

function FireballStorm(e: entity):
    wait 5 seconds
    while {_e} is alive:
        if {stun::%{_e}%} is not true:
            set {_custom} to tag "custom" of nbt of {_e}
            set {_instance} to tag "ECDungeonInstance" of {_custom}
            if metadata value  "ECPulled" of {_e} is set:
                set {_x} to block 10 above {_e}
                loop all blocks in radius 3 around {_x}:
                    add loop-block to {_blocks::*}
                loop 12 times:
                    set {_block} to a random element of {_blocks::*}
                    remove {_block} from {_blocks::*}
                    spawn 1 blaze fireball at {_block}
                    set {_fireball} to last spawned blaze fireball
                    set metadata value "Shooter" of {_fireball} to uuid of {_e}
                    set metadata value "FirebalType" of {_fireball} to "FireballStorm"
                    set {_target} to a random element of {-dungeonInstance%{_instance}%::*}
                    push {_fireball} (vector from {_block} to ({_target})) with speed 2
                    play sound "entity.blaze.shoot" with volume 3 and pitch 1 at {_e}
                    wait 0.2 seconds
        wait 12 seconds

function DestructionArrow(e: entity):
    while {_e} is alive:
        if {stun::%{_e}%} is not true:
            set {_instance} to tag "custom;ECDungeonInstance" of nbt of {_e}
            set {_target} to a random element of {-dungeonInstance%{_instance}%::*}
            loop 3 times:
                stop if {_e} is not alive
                set {_hand} to hand({_e}, 0, 0.05)
                set {_shape} to sphere with radius (loop-number*0.2)
                draw {_shape} at {_hand}
                play sound "item.flintandsteel.use" with volume 3.5 and pitch (0.67*loop-number) at {_e}
                wait 1 second
            if {_target} is alive:
                if {_instance} = metadata value "DungeonInstance" of {_target}:
                    if 40 >= distance between {_e} and {_target}:
                        play sound "entity.ghast.scream" with volume 3.5 and pitch 0 at {_e}
                        play sound "entity.tnt.primed" with volume 3.5 and pitch 0 at {_e}
                        play sound "entity.ghast.shoot" with volume 3.5 and pitch 0 at {_e}
                        play sound "entity.generic.explode" with volume 3.5 and pitch 2 at {_e}
                        spawn 1 arrow at {_hand}
                        set {_arrow} to last spawned arrow
                        set tag "custom;Invisible" of nbt of {_arrow} to true
                        set {_l} to location of {_arrow}
                        set {_yaw} to yaw of {_e}
                        set {_pitch} to pitch of {_e}
                        set yaw of {_l} to {_yaw}
                        set pitch of {_l} to {_pitch}
                        set {_targetLoc} to location 0.5 below {_target}
                        loop round(distance between {_l} and {_targetLoc}) / 1 times:
                            set {_targetLoc} to location 0.5 below {_target}
                            set {_vec} to vector between {_l} and {_targetLoc}
                            set vector length of {_vec} to loop-value * 2
                            teleport {_arrow} to {_l} ~ {_vec}
                            set {_arrowLoc} to location of {_arrow}
                            increase y-coordinate of {_arrowLoc} by 2 
                            draw 1 of dust using dustOption((rgb 252, 107, 3), 1) at {_arrowLoc}
                            draw 1 of dust using dustOption((rgb 125, 65, 46), 1) at {_arrowLoc}
                            wait 1 tick
                        kill {_arrow}
                        if {_target} is alive:
                            if {-dungeonInstance%{_instance}%::*} contains {_target}:
                                DamageProperties({_target}, {_e}, "<##993d1f>Strzała Destrukcji", "<##993d1f>Destruction Arrow", {_lore}, {_loreEN}, 3)
        wait 8 seconds

#Magic Tome
function RandomAbility(e: entity):
    set {_abilities::*} to "Shadowy Apparition", "Inferno", "Explosive Bubble"
    set {_instance} to tag "custom;ECDungeonInstance" of nbt of {_e}
    wait 2 ticks
    while {_e} is alive:
        set {_randomAbility} to a random element of {_abilities::*}
        if {_randomAbility} = "Shadowy Apparition":
            loop {-dungeonInstance%{_instance}%::*}:
                set {_target} to loop-value
                spawn 1 bee at {_e} with nbt from "{Silent:1b}"
                set the name of last spawned bee to "Shadowy Apparition"
                set tag "custom;ECSummoned" of nbt of last spawned bee to "%{_e}%"
                set {_shadowyApparition} to last spawned bee
                ShadowyApparitionFloatMagicTome({_e}, {_shadowyApparition}, {_target}, {_instance})
                ShadowyApparitionVisual({_shadowyApparition})
                play sound "skill.therold.shadowy_apparitions" with volume 2 and pitch 1 at {_e}
                if cooldown "Shadowy Apparition Sound-%{_e}%" is finished:
                    set {_pitch} to a random number between 0.8 and 1.1
                    play sound "skill.therold.shadowy_apparitions_whisper" with volume 2 and pitch {_pitch} at {_e}
                    set {_random} to a random number between 1 and 1.5
                    create cooldown "Shadowy Apparition Sound-%{_e}%" for ("%{_random}% seconds" parsed as timespan)
        else if {_randomAbility} = "Inferno":
            set {_lore} to "&8Umiejętność%nl%&fInstant cast%nl%&7Cooldown: &fbrak%nl%&7Użycie: &fPPM&7/&fSHIFT%nl%<##e53311>Więzi przeciwnika podpalonego Miotaczem Płomieni%nl%<##e53311>w ognistym więzieniu, ogłuszając go na &f%{_stuntekst}% sekund%nl%<##e53311>i zadajac &f%{_dmg}% <##e53311>obrażeń <##ff4d00>Ognia<##e53311>.%nl% %nl%<##e53311>Kliknięcie Shiftem zdetonuje więzienie,%nl%<##e53311>zadając &f%{_explotekst}% <##e53311>damage <##ff4d00>Ognia <##e53311>i podrzucając wroga do góry."
            set {_loreEN} to "&8Ability%nl%&fInstant cast%nl%&7Cooldown: &fnone%nl%&7Use: &fRMB&7/&fSHIFT%nl%<##e53311>Imprisons the target affected by Flamethrower%nl%<##e53311>in a fiery prison, stunning them for &f%{_stun}%%nl%<##e53311>and inflicting &f%{_dmg}% <##ff4d00>Fire <##e53311>damage.%nl% %nl%<##e53311>Pressing Shift will detonate the prison,%nl%<##e53311>dealing &f%{_explotekst}% <##ff4d00>Fire <##e53311>damage and tossing the%nl%<##e53311>enemy into the air."
            loop {-dungeonInstance%{_instance}%::*}:
                set {_target} to loop-value
                set {infernotarget::%{_target}%} to true
                if canBeCCed({_target}) = true:
                    InfernoTimerMagicTome({_e}, {_target}, {_instance}, 3)
                    set metadata value "Element" of {_e} to "Fire"
                    DamageProperties({_target}, {_e}, "<##e53311>Inferno", "<##e53311>Inferno", {_lore}, {_loreEN}, 2)
                    InfernoParticles({_target})
                    play sound "entity.illusioner.mirror_move" with volume 2.5 and pitch 1 at {_e}
        else if {_randomAbility} = "Explosive Bubble":
            set {_lore} to "&8Umiejętność%nl%&fInstant cast%nl%&7Cooldown: &f%{_cd}% sekund | %{_cdtarget}% sekund na cel%nl%&7Użycie: &fPPM%nl%<##7cafbf>Otacza wybranego sojusznika wybuchowym bąbelkiem,%nl%<##7cafbf>zapewniając tarczę absorbującą &f%{_shield}% <##7cafbf>obrażeń.%nl%<##7cafbf>Po &f%{_wait}% sekundach <##7cafbf>bąbelek wybucha, zadającc%nl%&f%{_damage}% + pozostała wartość tarczy <##7cafbf>jako%nl%<##1ebbd7>Wodne <##7cafbf>obrażenia pobliskim wrogom."
            set {_loreEN} to "&8Ability%nl%&fInstant cast%nl%&7Cooldown: &f%{_cd}% seconds | %{_cdtarget}% seconds per target%nl%&7Use: &fRMB%nl%<##7cafbf>Wraps an ally in an explosive bubble,%nl%<##7cafbf>which absorbs &f%{_shield}% <##7cafbf>damage.%nl%<##7cafbf>After &f%{_wait}% seconds<##7cafbf>, the bubble explodes,%nl%<##7cafbf>dealing &f%{_damage}% + remaining shield amount <##7cafbf>as <##1ebbd7>Water <##7cafbf>damage%nl%<##7cafbf>to enemies nearby."
            set {_pid} to random 8 char string from charset `0-9`
            set {_uuid} to uuid of {_e}
            set {tarcza::%{_uuid}%} to 0.15*max health of {_e}
            play sound "block.bubble_column.whirlpool_inside" with volume 3 and pitch 1 at {_e}
            set {_shape} to a sphere with radius 3
            set particle of {_shape} to bubble
            draw {_shape} at {_e}
            set {_shape} to a sphere with radius 3
            set particle of {_shape} to splash
            draw {_shape} at {_e}
            set {_haste} to metadata value "Haste" of {_e}
            set {_hastered} to 1 + (({_haste}/4)/100)
            set {_wait} to 4.5/{_hastered}
            set {_wait} to ("%{_wait}% seconds" parsed as timespan)
            wait {_wait}
            if {_e} is alive:
                if {tarcza::%{_uuid}%} < 0:
                    clear {tarcza::%{_uuid}%}
                if {tarcza::%{_uuid}%} > 0:
                    play sound "entity.dragon_fireball.explode" with volume 3 and pitch 1 at {_e}
                    loop all players in radius 10 around {_e}:
                        if loop-player is alive:
                            if metadata value "DungeonInstance" of loop-player = {_instance}:
                                set metadata value "Element" of {_e} to "Water"
                                DamageProperties(loop-player, {_e}, "<##7cafbf>Wybuchowy Bąbelek", "<##7cafbf>Explosive Bubble", {_lore}, {_loreEN}, {tarcza::%{_uuid}%})
            clear {tarcza::%{_uuid}%}

        wait 12 seconds
function ShadowyApparitionFloatMagicTome(e: entity, apparition: entity, target: entity, instance: number):
    while distance between {_apparition} and {_target} > 2:
        make {_apparition} pathfind to {_target}
        {_apparition}.setFlower(null)
        wait 5 ticks
        stop loop if {_target} is not alive
        stop loop if {-dungeonInstance%{_instance}%::*} does not contain {_target}
    if {_target} is alive:
        if {-dungeonInstance%{_instance}%::*} contains {_target}:
            set {_lore} to "&8Mastery Bonus%nl%<##613e82>When your Shadow Word: Pain damage%nl%<##613e82>over time critically strikes, you also create%nl%<##613e82>a shadowy version of yourself that floats%nl%<##613e82>towards the target and deals &f%{_damage}% <##613e82>damage."
            set metadata value "Element" of {_e} to "Ghost"
            DamageProperties({_target}, {_e}, "<##462566>Cieniste Aparycje", "<##462566>Shadowy Apparitions", {_lore}, {_lore}, 4)
    teleport {_apparition} to location(0, -100, 0)
    kill {_apparition}

function InfernoTimerMagicTome(e: entity, p: player, instanceMob: number, timer: integer):
    set {stun::%{_p}%} to true
    while {_timer} > 0:
        stop loop if {-dungeonInstance%{_instanceMob}%::*} does not contain {_p}
        stop loop if {_p} is not alive
        stop loop if {_e} is not alive
        broadcast ":P!"
        wait 1 second
        remove 1 from {_timer}
    clear {stun::%{_p}%}
    clear {infernotarget::%{_p}%}


on projectile collide:
    if event-projectile is blaze fireball:
        cancel event
        if metadata value "Shooter" of event-projectile is set:
            set {_shooter} to (metadata value "Shooter" of event-projectile) parsed as entity
            clear metadata value "Shooter" of event-projectile
            if tag "custom;ECMob" of nbt of {_shooter} is set:
                if event-entity is a player:
                    if name of {_shooter} = "Destruction Mage":
                        set {_instance} to tag "custom;ECDungeonInstance" of nbt of {_shooter}
                        if {_instance} is set:
                            if metadata value "FirebalType" of event-projectile = "Fireball":
                                clear metadata value "FirebalType" of event-projectile
                                DamageProperties(event-entity, {_shooter}, "<##e3691e>Kula Ognia", "<##e3691e>Fireball", {_lore}, {_loreEN}, 1.75)
                            else if metadata value "FirebalType" of event-projectile = "FireballStorm":
                                clear metadata value "FirebalType" of event-projectile
                                DamageProperties(event-entity, {_shooter}, "<##e3691e>Burza Kul Ognia", "<##e3691e>Fireball Storm", {_lore}, {_loreEN}, 1.5)

    if event-projectile is large fireball:
        cancel event
        if metadata value "Shooter" of event-projectile is set:
            set {_shooter} to (metadata value "Shooter" of event-projectile) parsed as entity
            clear metadata value "Shooter" of event-projectile
            if tag "custom;ECMob" of nbt of {_shooter} is set:
                if event-entity is a player:
                    if name of {_shooter} = "Destruction Mage":
                        set {_instance} to tag "custom;ECDungeonInstance" of nbt of {_shooter}
                        if {_instance} is set:
                            DamageProperties(event-entity, {_shooter}, "<##e3691e>Kula Destrukcji", "<##e3691e>Destruction Ball", {_lore}, {_loreEN}, 6)
on projectile hit:
    if event-projectile is blaze fireball:
        cancel event
        if metadata "Shooter" of event-projectile  is set:
            clear metadata "Shooter" of event-projectile 
            clear metadata value "FirebalType" of event-projectile
    if event-projectile is wither skull:
        cancel event
    if event-projectile is large fireball:
        if metadata "Shooter" of event-projectile  is set:
            clear metadata "Shooter" of event-projectile 
            clear metadata value "FirebalType" of event-projectile

import:
    org.bukkit.event.block.BlockIgniteEvent
    
on BlockIgniteEvent:
    if event.getCause() = BlockIgniteEvent.IgniteCause.FIREBALL:
        cancel event

function hand(p: entity, deg: integer, infront: number) :: location:
    set {_v} to spherical vector radius 1, yaw 0, pitch {_deg}
    set {_v2} to spherical vector radius 2, yaw {_p}'s yaw, pitch {_p}'s pitch
    rotate {_v} around y-axis by {_p}'s yaw * -1 + 90
    rotate {_v} around (vector from yaw {_p}'s yaw + 90 and pitch 0) by {_p}'s pitch * -1
    return location {_infront} meters infront of {_p}'s eyes ~ {_v} ++ {_v2}
on region enter:
    if "%region%" contains "SiegeOfSpawnPortal":
        if {poziom::%player%} >= 30:
            if 1 = 1: #if questline has been completed
                if player is in a party:
                    if {karta::%player%} is set:
                        play sound "block.portal.travel" with volume 2 and pitch 1 at player
                        teleport the player to location(-626.5, 81, -535.5, world "areny")
                        play sound "block.portal.travel" with volume 2 and pitch 1 to player
                    else:
                        if {language::%player%} = "English":
                            send "&cYou must have a Card selected to enter a Dungeon." to player
                        else:
                            send "&cMusisz mieć wybraną kartę, by móc wejść w Dungeon." to player
                else:
                    if {language::%player%} = "English":
                        send "&cYou must be in a party to enter a Dungeon." to player
                    else:
                        send "&cMusisz być w party, by móc wejść w Dungeon." to player
            else:
                if {language::%player%} = "English":
                    send "&cYou must complete the necessary questline to enter this Dungeon." to player
                else:
                    send "&cMusisz ukończyć wymagany quest, by móc wejść w ten Dungeon." to player
        else:
            if {language::%player%} = "English":
                send "&cYou must be at least level 30 to enter Dungeons." to player
            else:
                send "&cMusisz mieć conajmniej 30 poziom, by móc wchodzić w Dungeony." to player
            play sound "block.glass.break" with volume 5 and pitch 0 to player
    set {_instance} to metadata value "DungeonInstance" of player
    if "%region%" contains "SiegeOfSpawn1" or "SiegeOfSpawn2" or "SiegeOfSpawn3":
        if {_instance} is set:
            if {_instance} > 0:
                if "%region%" does not contain "%{_instance}%":
                    if {language::%player%} = "English":
                        send "&cDungeon in progress: cannot enter area." to player
                    else:
                        send "&cDungeon w toku: nie można wejść na teren." to player
#NO TEXT ABOVE
#on rightclick:
#    if player's tool is stone hoe:
 #       spawn 1 skeleton at block above target block of player with nbt compound from "{Silent:1b}"
 #       set {_x} to last spawned skeleton
 #       set the name of {_x} to "merimelle"
 #       DungeonMobAssignment({_x}, true, 70)
#        set tag "ecmob" of nbt of {_x} to true
 #       set {_custom} to tag "custom" of nbt compound of {_x}
 #       set {_id} to tag "ECBossBossBar" of {_custom}
 #       apply potion of swiftness 3.5 without particles to {_x} for 24 hours
 #       set {_uuid} to uuid of {_x}
  #      execute console command "/disguuid %{_uuid}% player nishikoru setCustomName ""merimelle"" setDynamicName true setCustomNameVisible true"
   #     set {_bar} to boss bar with id {_id} with title name of last spawned skeleton with color blue
  #      add player to {_bar}
   #     set bar style of {_bar} to segmented 20
   #     set bar flag darken sky of {_bar} to true

#CLEAR ARENA
#on death:
#if tag "custom" of nbt compound of victim is set:
#    set {_custom} to tag "custom" of nbt compound of victim
 #   if tag "ECBoss" of {_custom} is set:
 #       if name of victim = "merimelle":
 #           if {-intermissionLila::%victim%::*} is set:
 #               set {_count} to 1
 #               loop {-intermissionLila::%victim%::*}:
  #                  set {_ll} to {-intermissionLilaloc::%victim%::%{_count}%}
   #                 set {_world} to world of {-intermissionLilaloc::%victim%::%{_count}%}
   #                 set {_loc} to location(x-coordinate of {_ll}-0.5, y-coordinate of {_ll}-0.5, z-coordinate of {_ll}-0.5, world {_world})
 #                   set {-intermissionLilaloc::%victim%::%{_count}%} to {_loc}
  #                  set block above {-intermissionLilaloc::%victim%::%{_count}%} to air
   #                 set block at {-intermissionLilaloc::%victim%::%{_count}%} to {-intermissionLila::%victim%::%{_count}%}
  #                  add 1 to {_count}
  #              clear {-intermissionLila::%victim%::*}
   #             clear {-intermissionLilaloc::%victim%::*}